<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./libs/d3.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
    <script src="https://unpkg.com/d3-simple-slider"></script>
    <title>Vinography</title>
    <style>
        #tooltip {
            position: absolute;
            opacity: 0;
            top: 0;
            left: 0;
            width: auto;
            padding: 10px;
            background: white;
            font-family: sans-serif;
            font-size: medium;
            border-radius: 2px;
            line-height: 1;
        }

        #infobox {
            position: absolute;
            right: 20px;
            opacity: 0;
            width: auto;
            padding: 10px;
            margin: 10px;
            background: lightgray;
            font-family: sans-serif;
            font-size: medium;
            border-radius: 2px;
            line-height: 1;
            z-index: 10;
        }
        
        path {
            stroke-width: .5px;
            stroke: black
        }
        
        path:hover {
            opacity: .6;
            stroke: black;
            stroke-width: 4px;
        }
        datalist {
            display: flex;
            justify-content: space-between;
            width: 75%;
        }
    </style>
</head>

<body>
    <div id="header">
    <h1 style="text-align: center">World Wine Production and Trade</h1>
    <!-- <h3 style="text-align: center">Thomas Briggs</h3> -->
    </div>
    <!-- Keeping this because I fear it's necessary to do things this way for animation
    <div id="slidercontainer">
        <div style="width: 50%; margin: auto;">
        <input type="range" min="2000" max="2019" value="2019" class="slider" id="yearSlider" style="width: 400px; margin: auto;" list="tickmarks">
        <datalist id="tickmarks">
            <option value="2000" label="2000"></option>
            <option value="2001"></option>
            <option value="2002"></option>
            <option value="2003"></option>
            <option value="2004"></option>
            <option value="2005"></option>
            <option value="2006"></option>
            <option value="2007"></option>
            <option value="2008"></option>
            <option value="2009"></option>
            <option value="2010" label="2010"></option>
            <option value="2011"></option>
            <option value="2012"></option>
            <option value="2013"></option>
            <option value="2014"></option>
            <option value="2015"></option>
            <option value="2016"></option>
            <option value="2017"></option>
            <option value="2018"></option>
            <option value="2019" label="2019"></option>
        </datalist>
        </div>
    </div>
    -->
    <div style="width: 50%; margin: auto;">
        <div id="yearSlider"></div>
    </div>
    <div id="map">
    </div>
    <div id="legendContainer" style="width: 100%;"></div>


    <div id="tooltip"></div>
    <div id="infobox"></div>
    <script>

        // dimension of the page
        const window_dims = {
            width: window.innerWidth,
            height: window.innerHeight
        };
        const margin = window_dims.width * .2

        const worldMap = "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"
        const countryCodesFile = "data/countryCodes.json"
        const OIV_data = "data/OIV_data.csv"

        const defaultYear = 2019;

        // load both files
        Promise.all([
            d3.json(worldMap),
            d3.dsv(';', OIV_data),
            d3.json(countryCodesFile)
        ]).then(data => {
            // topology data
            geojson = data[0];
            // production data
            OIVcsv = data[1];
            // country codes
            countryCodes = data[2]

            addSlider(OIVcsv, defaultYear)
            doAllTheThings(defaultYear)
        })

        function doAllTheThings(dataYear)
        {
            const wineProductionSeries = "Wine production"
            //let dataYear = +d3.select("#yearSlider").node().value

            // Need to be able to find OIV data by country name in order to apply colors
            let OIVNameDict = {}
            countryCodes.forEach(d => OIVNameDict[d.name] = d.oivname);

            function getOneYearProduction(dataYear)
            {
                return OIVcsv.filter(d => +d.Year === dataYear && d.Series === wineProductionSeries)
            }

            function drawWorldMap() {
                prodOneYear = getOneYearProduction(dataYear)
                prodDict = {}
                prodOneYear.forEach(d => prodDict[d.Country] = d)

                const prodValues = d3.map(prodOneYear, d => +d.Value).filter(d => d > 0)

                let prodExtent = d3.extent(prodValues)
                let colorScale = d3.scaleSequential(d3.interpolateOrRd).domain(prodExtent)

                let svg = d3.select("#map")
                    .append("svg")
                    .attr("id", "mapSVG")
                    .attr("width", 1200)
                    .attr("height", 600)
                    .attr("viewBox", "0 0 1200 600")
                const width = window_dims.width - margin
                const height = window_dims.height - margin

                let projection = d3.geoNaturalEarth1()
                    //.scale(80)
                    .center([0, 20])
                    .translate([width / 2, height / 2]);

                const geoPath_generator = d3.geoPath()
                    .projection(projection)

                const tooltip = d3.select("#tooltip");
                const infobox = d3.select("#infobox");

                let found = {}
                svg.selectAll("path")
                    .data(geojson.features)
                    .enter()
                    .append("path")
                    .attr("d", d => geoPath_generator(d))
                    .attr("fill", function (d) {
                        let thisProd = 0
                        const oivName = OIVNameDict[d.properties["name"]]
                        if (prodDict[oivName]) {
                            thisProd = +prodDict[oivName].Value
                            found[oivName] = 1
                        }

                        return thisProd === 0 ? "white" : colorScale(thisProd)
                    })

                Object.keys(prodDict).forEach(k => {
                    if (!found[k])
                        console.log("Production data not used for " + k)
                })

                /*
                .on("mouseenter", (m, d) => {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9)
                    tooltip.html(d['properties']['TOWN'])
                        .style("left", m.clientX + "px")
                        .style("top", m.clientY + "px");

                    let thisCountyFIPS = d['properties']['FIPS_STCO']

                    let paths = d3.select("body").select("svg").selectAll("path")
                    // Highlight all the towns in this county
                    paths
                        .filter(function(p) { return p['properties']['FIPS_STCO'] === d['properties']['FIPS_STCO'] })
                        .attr('style', "stroke-width: 2px")
                        .attr('fill', 'none')
                    paths
                        .filter(function(p) { return p['properties']['FIPS_STCO'] === d['properties']['FIPS_STCO'] })
                        .attr('style', "stroke-width: 0px")
                        .attr('fill', 'firebrick')


                    // Make sure none of the other towns are highlighted
                    paths
                        .filter(function(p) { return p['properties']['FIPS_STCO'] !== d['properties']['FIPS_STCO'] })
                        .attr('style', "stroke-width: 0.5px")
                        .attr("fill", d => colorInterpolator(inearScale(d['properties'][datasetName])))

                    let infotxt = countyNames[thisCountyFIPS] + " County";
                    let numTowns = 0;
                    let totalPopulation = 0;
                    geojson.features.forEach(c => {
                        if(c['properties']['FIPS_STCO'] === thisCountyFIPS) {
                            numTowns++
                            totalPopulation += c['properties']['POP2010']
                        }
                    })
                    infotxt += "<br/>" + numTowns + " towns"
                    infotxt += "<br/>" + "2010 Total population: " + totalPopulation;

                    infobox.transition()
                        .duration(200)
                        .style("opacity", .9)
                    infobox.html(infotxt)
                })
                .on("mousemove", (m, d) => {
                    tooltip.style("opacity", .9)
                    infobox.style("opacity", .9)
                })
                .on("mouseout", (m, d) => {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", 0)
                    infobox.transition()
                        .duration(200)
                        .style("opacity", 0)
                })
                 */

                function drawLegend() {
                    let padding = 20;
                    let width = 320;
                    let innerWidth = width - (padding * 2);
                    let barHeight = 8;
                    let height = 28;

                    let xScale = d3.scaleSequential()
                        .range([0, innerWidth])
                        .domain(prodExtent)

                    let sortedProdValues = prodValues.sort((a, b) => a - b)
                    let aquarter = parseInt((prodExtent[1] - prodExtent[0]) / 4)

                    /*
                    // This seems like what we want but the bin function doesn't guarantee equal sized buckets
                    let fbin = d3.bin().thresholds(4)
                    let bins = fbin(sortedProdValues)
                    let xTicks = bins.map(d => d3.min(d))

                    // We could also do simply axisBottom().ticks(#) but that shows
                    // "nice" values, which in this case I don't want
                    */
                    let xTicks = [prodExtent[0],
                        prodExtent[0] + aquarter,
                        prodExtent[0] + (2 * aquarter),
                        prodExtent[0] + (3 * aquarter),
                        prodExtent[1]]

                    let xAxis = d3.axisBottom(xScale)
                        .tickSize(barHeight * 2)
                        .tickValues(xTicks);

                    let oldSvg = d3.select("#legendSvg").remove()
                    let svg = d3.select("#legendContainer")
                        .append("svg")
                        .attr("id", "legendSvg")
                        .attr("width", width)
                        .attr("height", height)
                        .attr("style", "margin-left: " + (1200 - width)/2)
                    let g = svg.append("g").attr("transform", "translate(" + padding + ", 0)");

                    let defs = svg.append("defs");
                    let linearGradient = defs.append("linearGradient").attr("id", "myGradient");
                    linearGradient.selectAll("stop")
                        .data(sortedProdValues)
                        .enter().append("stop")
                        .attr("offset", d => ((d - prodExtent[0]) / (prodExtent[1] - prodExtent[0]) * 100) + "%")
                        .attr("stop-color", d => colorScale(d))

                    g.append("rect")
                        .attr("width", innerWidth)
                        .attr("height", barHeight)
                        .style("fill", "url(#myGradient)")

                    g.append("g")
                        .call(xAxis)
                        .select(".domain").remove();
                }

                drawLegend()
            }

            function sliderChange(d) {
                d3.select("#mapSVG").remove()
                doAllTheThings()
            }
            //dumpCountryCodes(geojson)
            drawWorldMap()
            d3.select("#yearSlider").on("change",sliderChange)
        }

        function addSlider(OIVcsv, defaultYear)
        {
            const sliderWidth = 300

            let yearList = new Set(d3.map(OIVcsv, d => +d.Year))

            const maxVal = d3.max(yearList)

            let tickList = Array.from(yearList).filter(function (d, i) { return i % 5 === 0 })
            if (maxVal % 5 !== 0)
                tickList.push(maxVal)

            let yearSlider = d3.sliderHorizontal()
                .min(d3.min(yearList))
                .max(maxVal)
                .width(sliderWidth)
                .tickFormat(d3.format('.4'))
                //.tickValues([2000, 2005, 2010, 2015, 2019])
                .tickValues(tickList)
                .ticks(yearList.size)
                .default(defaultYear)
                .on('onchange', val => {
                    d3.select("#mapSVG").remove()
                    doAllTheThings(parseInt(Math.round(val)))
                });

            var g = d3.select("div#yearSlider")
                .append("svg")
                .attr("width", 500)
                .attr("height", 100)
                .append("g")
                .attr("transform", "translate(30,30)")
                .attr("id", "d3slider")
                .call(yearSlider)
        }

        function dumpCountryCodes(geojson)
        {
            countries = d3.map(geojson.features, d => {
                return {code: d.id, name: d.properties["name"], oivname: d.properties["name"]}
            })
            console.log(countries)
        }
    </script>
</body>

</html>
